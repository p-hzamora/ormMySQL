from __future__ import annotations
from typing import Callable

import pytest

from decimal import Decimal
from datetime import datetime


from ormlambda import ORM, Alias, IStatements
from test.models import (
    Address,
    _TestTable,
    TableWithAutoGenerated,
)  # noqa: E402

from ormlambda import Max, Min, Sum, Engine


from pydantic import BaseModel, ConfigDict

DB_NAME = "__test_ddbb__"
TABLETEST = _TestTable.__table_name__


@pytest.fixture(scope="module", autouse=True)
def create_and_drop_schema(engine_no_db: Engine):
    engine_no_db.create_schema(DB_NAME, "replace")

    yield

    engine_no_db.drop_schema(DB_NAME)


@pytest.fixture(scope="module")
def tengine(create_engine_for_db: Callable[[str], Engine]):
    engine = create_engine_for_db(DB_NAME)

    model = ORM(_TestTable, engine)
    model.create_table()

    yield engine

    model.drop_table()


@pytest.fixture
def tmodel(tengine):
    """Engine connected to test database"""
    model = ORM(_TestTable, tengine)

    yield model

    model.delete()


@pytest.fixture
def automodel(tengine):
    """Engine connected to test database"""
    model = ORM(TableWithAutoGenerated, tengine)

    yield model

    model.delete()


def create_instance_of_TestTable(number: int) -> list[_TestTable]:
    if number <= 0:
        number = 1
    return [_TestTable(*[x] * len(_TestTable.__annotations__)) for x in range(1, number + 1)]


def create_instance_of_TestTableAUTOGENERATED(number: int) -> list[_TestTable]:
    if number <= 0:
        raise ValueError("You must specified a number greater than 0")

    res_output = []
    for x in range(1, number + 1):
        res_output.append(TableWithAutoGenerated(Col_pk_auto_increment=x, Col_auto_generated=None, Col3=x, Col4=x))
    return res_output


# region TestFunctionFunctions
@pytest.fixture(autouse=True)
def init_test_function(tmodel: IStatements[_TestTable]):
    instance = create_instance_of_TestTable(10)
    tmodel.insert(instance)


@pytest.mark.skip("# FIXME [ ]: see who to deal when using columns outside a lambda function")
def test_max_function(tmodel: IStatements[_TestTable]) -> None:
    max_fn = Max(lambda x: x.Col1, alias="max_with_alias")
    min_fn = Min(lambda x: x.Col1, alias="min_with_alias")
    sum_fn = Sum(lambda x: x.Col1, alias="sum_with_alias")
    select = tmodel.select(
        (
            max_fn,
            min_fn,
            sum_fn,
        ),
        flavour=dict,
    )

    dicc = {
        "max_with_alias": 10,
        "min_with_alias": 1,
        "sum_with_alias": Decimal("55"),  # FIXME [ ]: I don't know why return 'Decimal' instead 'int'
    }
    assert select[0] == dicc


def test_max_function(tmodel: IStatements[_TestTable]) -> None:
    select = tmodel.select(
        lambda x: (
            Max(x.Col1, alias="max_with_alias"),
            Min(x.Col1, alias="min_with_alias"),
            Sum(x.Col1, alias="sum_with_alias"),
        ),
        flavour=dict,
    )

    dicc = {
        "max_with_alias": 10,
        "min_with_alias": 1,
        "sum_with_alias": Decimal("55"),  # FIXME [ ]: I don't know why return 'Decimal' instead 'int'
    }
    assert select[0] == dicc


def test_min_function(tmodel: IStatements[_TestTable]) -> None:
    select = tmodel.select_one(
        lambda x: Min(x.Col1, alias="min_with_alias"),
        flavour=dict,
    )

    dicc = {"min_with_alias": 1}
    assert "min_with_alias" in select
    assert select == dicc


def test_sum_function(tmodel: IStatements[_TestTable]) -> None:
    select = tmodel.select_one(lambda x: Sum(x.Col10, alias="custom_sum"), flavour=dict)
    dicc = {"custom_sum": Decimal("55")}
    assert select == dicc


def test_in_statement(amodel: IStatements[Address]):
    filter_by = (1, 2, 3, 4, 5, 6, 7, 8, 9)
    select = amodel.where(lambda x: x.address_id.contains(filter_by)).select(lambda x: x.address_id, flavour=tuple)
    assert select == filter_by


def test_select_with_custom_flavour(amodel: IStatements[Address]):
    class AddressCombine(BaseModel):
        address: str
        city: str
        country: str

        model_config: ConfigDict = {"extra": "forbid"}

    select = (
        amodel.order(lambda x: x.City.Country.country, "DESC")
        .limit(10)
        .where(lambda x: x.City.Country.country == "Spain")
        .first(
            lambda x: (
                Alias(x.address, "address"),
                Alias(x.City.city, "city"),
                Alias(x.City.Country.country, "country"),
            ),
            flavour=AddressCombine,
        )
    )

    assert isinstance(select, AddressCombine)
    assert select.address == "939 Probolinggo Loop"
    assert select.country == "Spain"
    assert select.city == "A Coruña (La Coruña)"


def test_return_all_results_beside_calling_columns_with_the_same_names(amodel: IStatements[Address]):
    # FIXME []: We should provide types for new TypeEngine object. That's the reason 'python_type' wasn't detected
    res = amodel.first(
        lambda x: (
            x.last_update,
            x.City.last_update,
            x.City.Country.last_update,
        ),
        flavour=dict,
        alias=lambda x: "{table}~{column}" + f"[{x.dtype.python_type.__name__}]",
    )
    EXPECTED = {
        "address~last_update[datetime]": datetime(2014, 9, 25, 22, 30, 27),
        "city~last_update[datetime]": datetime(2006, 2, 15, 4, 45, 25),
        "country~last_update[datetime]": datetime(2006, 2, 15, 4, 44),
    }
    assert res == EXPECTED


# endregion
