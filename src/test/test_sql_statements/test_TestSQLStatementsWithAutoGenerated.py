from __future__ import annotations
from typing import Callable

import pytest

from datetime import datetime


from ormlambda import ORM, IStatements
from test.models import (
    TableWithAutoGenerated,
)  # noqa: E402

from ormlambda import Engine


DB_NAME = "__test_ddbb__"


@pytest.fixture(scope="module", autouse=True)
def create_and_drop_schema(engine_no_db: Engine):
    engine_no_db.create_schema(DB_NAME, "replace")

    yield

    engine_no_db.drop_schema(DB_NAME)


@pytest.fixture(scope="module")
def tengine(create_engine_for_db: Callable[[str], Engine]):
    engine = create_engine_for_db(DB_NAME)

    model = ORM(TableWithAutoGenerated, engine)
    model.create_table()

    yield engine

    model.drop_table()


@pytest.fixture
def automodel(tengine):
    """Engine connected to test database"""
    model = ORM(TableWithAutoGenerated, tengine)

    yield model

    model.delete()


def create_instance_ofTableWithAutoGeneratedAUTOGENERATED(number: int) -> list[TableWithAutoGenerated]:
    if number <= 0:
        raise ValueError("You must specified a number greater than 0")

    res_output = []
    for x in range(1, number + 1):
        res_output.append(TableWithAutoGenerated(Col_pk_auto_increment=x, Col_auto_generated=None, Col3=x, Col4=x))
    return res_output


def create_test_table(automodel: IStatements[TableWithAutoGenerated]) -> None:
    return automodel.create_table()


def create_instance_of_TableWithAutoGenerated(number: int) -> list[TableWithAutoGenerated]:
    if number <= 0:
        raise ValueError

    return [TableWithAutoGenerated(*[x] * len(TableWithAutoGenerated.__annotations__)) for x in range(1, number + 1)]


def test_insert_with_autogenerated_columms(automodel: IStatements[TableWithAutoGenerated]):
    instance = TableWithAutoGenerated(None, None, 3, 4)
    first_select = automodel.select_one()
    automodel.insert(instance)
    second_select = automodel.select_one()

    assert first_select == ()
    assert instance.Col_pk_auto_increment is None
    assert instance.Col_auto_generated is None

    assert second_select.Col_pk_auto_increment is not None
    assert second_select.Col_auto_generated is not None
    assert () != second_select


def test_insert_with_autogenerated_columms_and_values_not_None(automodel: IStatements[TableWithAutoGenerated]):
    CURRENT_DATE = datetime(1998, 12, 16)
    CURRENT_PK = 10
    instance_10 = TableWithAutoGenerated(CURRENT_PK, CURRENT_DATE, 3, 4)
    first_select = automodel.select_one()
    automodel.insert(instance_10)
    second_select = automodel.select_one()

    assert first_select == ()

    assert second_select.Col_pk_auto_increment, CURRENT_PK
    assert second_select.Col_auto_generated != CURRENT_DATE

    instance_5 = TableWithAutoGenerated(5, CURRENT_DATE, 3, 4)
    automodel.insert(instance_5)
    instance_5 = automodel.where(lambda x: x.Col_pk_auto_increment == 5).select_one()
    assert instance_5.Col_pk_auto_increment, 5
    assert instance_5.Col_auto_generated != CURRENT_DATE


def test_update_with_autogenerated_columms(automodel: IStatements[TableWithAutoGenerated]):
    """
    Method to test that the auto-generated column cannot be modified by the .update method.
    """
    CURRENT_DATETIME = datetime(1998, 12, 16)
    # region insert
    data_to_insert = (
        TableWithAutoGenerated(1, Col3=13, Col4=14),
        TableWithAutoGenerated(2, Col3=23, Col4=24),
        TableWithAutoGenerated(3, Col3=33, Col4=34),
    )
    automodel.insert(data_to_insert)

    # endregion
    real_auto_generated_1, real_auto_generated_2, real_auto_generated_3 = automodel.select(lambda x: x.Col_auto_generated, flavour=tuple)

    # region update
    automodel.where(lambda x: x.Col_pk_auto_increment == 1).update(
        {
            TableWithAutoGenerated.Col_auto_generated: CURRENT_DATETIME,
            TableWithAutoGenerated.Col3: 333,
            TableWithAutoGenerated.Col4: 444,
        }
    )
    # endregion
    # check that the 'Col_auto_generated' col has not been updated with CURRENT_DATETIME and it is still keeping the 'REAL_AUTOGENERATED_VALUE'
    select = automodel.select(flavour=tuple)
    assert select == (
        (1, real_auto_generated_1, 333, 444),
        (2, real_auto_generated_2, 23, 24),
        (3, real_auto_generated_3, 33, 34),
    )


def test_upsert_with_autogenerated_columns(automodel: IStatements[TableWithAutoGenerated]):
    def get_Col_auto_generated_value(number: int):
        return automodel.where(lambda x: x.Col_pk_auto_increment == number).select_one().Col_auto_generated

    instance = create_instance_ofTableWithAutoGeneratedAUTOGENERATED(20)
    automodel.insert(instance)

    CURRENT_DATETIME = datetime(1998, 12, 16)

    upsert_inst = (
        TableWithAutoGenerated(5, CURRENT_DATETIME, 9999, 10000),
        TableWithAutoGenerated(10, CURRENT_DATETIME, 9999, 10000),
        TableWithAutoGenerated(15, CURRENT_DATETIME, 9999, 10000),
        TableWithAutoGenerated(20, CURRENT_DATETIME, 9999, 10000),
    )

    automodel.upsert(upsert_inst)
    select = automodel.select(flavour=tuple)
    RESULT: tuple[tuple[int, ...]] = (
        (1, get_Col_auto_generated_value(1), 1, 1),
        (2, get_Col_auto_generated_value(2), 2, 2),
        (3, get_Col_auto_generated_value(3), 3, 3),
        (4, get_Col_auto_generated_value(4), 4, 4),
        (5, get_Col_auto_generated_value(5), 9999, 10000),
        (6, get_Col_auto_generated_value(6), 6, 6),
        (7, get_Col_auto_generated_value(7), 7, 7),
        (8, get_Col_auto_generated_value(8), 8, 8),
        (9, get_Col_auto_generated_value(9), 9, 9),
        (10, get_Col_auto_generated_value(10), 9999, 10000),
        (11, get_Col_auto_generated_value(11), 11, 11),
        (12, get_Col_auto_generated_value(12), 12, 12),
        (13, get_Col_auto_generated_value(13), 13, 13),
        (14, get_Col_auto_generated_value(14), 14, 14),
        (15, get_Col_auto_generated_value(15), 9999, 10000),
        (16, get_Col_auto_generated_value(16), 16, 16),
        (17, get_Col_auto_generated_value(17), 17, 17),
        (18, get_Col_auto_generated_value(18), 18, 18),
        (19, get_Col_auto_generated_value(19), 19, 19),
        (20, get_Col_auto_generated_value(20), 9999, 10000),
    )
    assert RESULT == select


def test_select_with_flavour_as_tuple_when_query_is_empty(automodel: IStatements[TableWithAutoGenerated]):
    select = automodel.select(lambda x: x.Col3, flavour=tuple)
    assert select == ()


def test_select_one_with_flavour_as_tuple_when_query_is_empty(automodel: IStatements[TableWithAutoGenerated]):
    select = automodel.select_one(lambda x: x.Col3, flavour=tuple)
    assert select is None


def test_select_with_flavour_as_list_when_query_is_empty(automodel: IStatements[TableWithAutoGenerated]):
    select = automodel.select(lambda x: x.Col3, flavour=list)
    assert select == ()


def test_select_one_with_flavour_as_list_when_query_is_empty(automodel: IStatements[TableWithAutoGenerated]):
    select = automodel.select_one(lambda x: x.Col3, flavour=list)
    assert select is None


def test_select_with_flavour_as_set_when_query_is_empty(automodel: IStatements[TableWithAutoGenerated]):
    select = automodel.select(lambda x: x.Col3, flavour=set)
    assert select == ()


def test_select_one_with_flavour_as_set_when_query_is_empty(automodel: IStatements[TableWithAutoGenerated]):
    select = automodel.select_one(lambda x: x.Col3, flavour=set)
    assert select is None


def test_select_with_flavour_as_dict_when_query_is_empty(automodel: IStatements[TableWithAutoGenerated]):
    select = automodel.select(lambda x: x.Col3, flavour=dict)
    assert select == ()


def test_select_one_with_flavour_as_dict_when_query_is_empty(automodel: IStatements[TableWithAutoGenerated]):
    select = automodel.select_one(lambda x: x.Col3, flavour=dict)
    assert select is None


# endregion
