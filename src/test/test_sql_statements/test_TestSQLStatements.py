from __future__ import annotations
from typing import Callable

import pandas as pd
import pytest

from pathlib import Path
from mysql.connector import errors


from ormlambda.statements.base_statement import FunctionFunctionError
from ormlambda import ORM, IStatements
from test.models import (
    Address,
    _TestTable,
    TableWithAutoGenerated,
)  # noqa: E402

from ormlambda import Max, Min, Engine


DB_NAME = "__test_ddbb__"
TABLETEST = _TestTable.__table_name__


@pytest.fixture(scope="module", autouse=True)
def create_and_drop_schema(engine_no_db: Engine):
    engine_no_db.create_schema(DB_NAME, "replace")

    yield

    engine_no_db.drop_schema(DB_NAME)


@pytest.fixture(scope="module")
def tengine(create_engine_for_db: Callable[[str], Engine]):
    engine = create_engine_for_db(DB_NAME)

    model = ORM(_TestTable, engine)
    model.create_table()

    yield engine

    model.drop_table()


@pytest.fixture
def tmodel(tengine):
    """Engine connected to test database"""
    model = ORM(_TestTable, tengine)

    yield model

    model.delete()


@pytest.fixture
def automodel(tengine):
    """Engine connected to test database"""
    model = ORM(TableWithAutoGenerated, tengine)

    yield model

    model.delete()


def create_instance_of_TestTable(number: int) -> list[_TestTable]:
    if number <= 0:
        number = 1
    return [_TestTable(*[x] * len(_TestTable.__annotations__)) for x in range(1, number + 1)]


def create_instance_of_TestTableAUTOGENERATED(number: int) -> list[_TestTable]:
    if number <= 0:
        raise ValueError("You must specified a number greater than 0")

    res_output = []
    for x in range(1, number + 1):
        res_output.append(TableWithAutoGenerated(Col_pk_auto_increment=x, Col_auto_generated=None, Col3=x, Col4=x))
    return res_output


# region TestSQLStatements
def test_database_already_exists(tengine: Engine):
    with pytest.raises(errors.DatabaseError):
        tengine.create_schema(DB_NAME)


def test_create_table(tmodel: IStatements[_TestTable]):
    tmodel.create_table("replace")
    table_exists = tmodel.table_exists()

    assert table_exists,  f"failed 'test_create_table' due to Table '{TABLETEST}' should exist after creation."


def test_create_table_already_exists_fail(tmodel: IStatements[_TestTable]):
    tmodel.create_table("replace")
    with pytest.raises(ValueError):
        tmodel.create_table()


def test_insert(tmodel: IStatements[_TestTable]):
    csv_data = pd.read_csv(Path(__file__).parent / "csv_table.csv").to_dict("records")
    instance = [_TestTable(**x) for x in csv_data]

    VERIFICATION = instance[15]
    tmodel.insert(instance)
    id = VERIFICATION.Col1

    select_query = tmodel.where(lambda x: x.Col1 == id).select_one()
    assert VERIFICATION.to_dict() == select_query.to_dict()


# TODOM [x]: Add a test for update method once it has been created
def test_update_with_column_as_keys(tmodel: IStatements[_TestTable]):
    instance = create_instance_of_TestTable(5)
    tmodel.insert(instance)

    tmodel.where(lambda x: x.Col1 == 3).update(
        {
            _TestTable.Col2: 2,
            _TestTable.Col5: 5,
            _TestTable.Col13: 13,
        }
    )
    theorical_result = instance[2]
    theorical_result.Col2 = 2
    theorical_result.Col5 = 5
    theorical_result.Col13 = 13

    result = tmodel.where(lambda x: x.Col1 == 3).select_one()
    assert result == theorical_result


def test_update_with_str_as_keys(tmodel: IStatements[_TestTable]):
    ROW_TO_UPDATE = 3

    instance = create_instance_of_TestTable(3)
    tmodel.insert(instance)

    tmodel.where(lambda x: x.Col1 == ROW_TO_UPDATE).update(
        {
            "Col2": 22,
            "Col5": 55,
            "Col13": 133,
        },
    )

    result = tmodel.where(lambda x: x.Col1 == ROW_TO_UPDATE).select_one(
        lambda x: (
            x.Col2,
            x.Col5,
            x.Col13,
        ),
        flavour=tuple,
    )
    assert result == (22, 55, 133)


def test_update_raising_KeyError(tmodel: IStatements[_TestTable]):
    instance = create_instance_of_TestTable(5)
    tmodel.insert(instance)

    with pytest.raises(KeyError) as err:
        tmodel.where(lambda x: x.Col1 == 3).update(
            {
                Address.address: 2,
                _TestTable.Col5: 5,
                _TestTable.Col13: 13,
            }
        )

    mssg: str = "The column 'address' does not belong to the table '__test_table__'; it belongs to the table 'address'. Please check the columns in the query."
    assert mssg == str(err.value)


def test_raise_KeyError_updating_with_string_as_key(tmodel: IStatements[_TestTable]):
    instance = create_instance_of_TestTable(5)
    tmodel.insert(instance)

    with pytest.raises(KeyError) as err:
        tmodel.where(lambda x: x.Col1 == 3).update(
            {
                "lol": 2,
                _TestTable.Col5: 5,
                _TestTable.Col13: 13,
            }
        )

    mssg: str = "The column 'lol' does not belong to the table '__test_table__'. Please check the columns in the query."
    assert mssg == str(err.value)


def test_limit(tmodel: IStatements[_TestTable]):
    instance = create_instance_of_TestTable(20)
    tmodel.insert(instance)

    limit = tmodel.limit(1).select()
    select_one = tmodel.select_one()
    assert len(limit) == 1
    assert limit[0] == select_one


def test_only_last_added_limit_is_available(tmodel: IStatements[_TestTable]):
    instance = create_instance_of_TestTable(20)
    tmodel.insert(instance)

    limit = tmodel.limit(10).limit(5).limit(1).select()
    select_one = tmodel.select_one()
    assert limit[0] == select_one


def test_offset(tmodel: IStatements[_TestTable]):
    instance = create_instance_of_TestTable(21)
    tmodel.insert(instance)

    offset = tmodel.offset(10).select_one()
    select_row_11 = tmodel.where(lambda x: x.Col1 == 11).select_one()
    assert offset == select_row_11


def test_only_last_offset_is_available(tmodel: IStatements[_TestTable]):
    instance = create_instance_of_TestTable(21)
    tmodel.insert(instance)

    offset = tmodel.offset(10).offset(5).offset(10).select_one()
    select_row_11 = tmodel.where(lambda x: x.Col1 == 11).select_one()
    assert offset == select_row_11


def test_delete(tmodel: IStatements[_TestTable]):
    instance = create_instance_of_TestTable(5)
    tmodel.insert(instance)

    tmodel.where(lambda x: x.Col1 == 2).delete()
    select_all = tmodel.select(lambda x: x.Col1, flavour=tuple)
    assert (1, 3, 4, 5) == select_all


def test_delete_passing_instance(tmodel: IStatements[_TestTable]):
    instance = create_instance_of_TestTable(5)
    tmodel.insert(instance)

    tmodel.delete(_TestTable(2))
    select_all = tmodel.select(lambda x: x.Col1, flavour=tuple)
    assert (1, 3, 4, 5) == select_all


def test_select_and_where_clause(amodel: IStatements[Address]):
    select = amodel.where(lambda x: (x.address_id <= 50) & (x.address_id >= 10)).select_one(
        lambda x: (
            Max(x.address_id),
            Min(x.address_id),
        ),
        flavour=dict,
    )

    dicc = {
        "max": 50,
        "min": 10,
    }
    assert dicc == select


def test_where_passing_tuples(amodel: IStatements[Address]):
    # fmt: off
    select = (
        amodel
        .order(lambda x: x.address_id, order_type="ASC")
        .where(lambda x:
            (
                x.address_id >= 40,
                x.address_id < 100,
                x.City.city_id >= 30,
                x.City.city_id < 100,
                x.City.Country.country_id >= 60,
                x.City.Country.country_id < 100,
            ),
        )
        .select(
            lambda x: (
                x.address_id,
                x.City.city_id,
                x.City.Country.country_id,
            ),
            flavour=dict,
        )
    )
    # fmt: on

    tuple_: tuple[dict[str, int]] = (
        {"address_id": 59, "city_id": 49, "country_id": 80},
        {"address_id": 65, "city_id": 56, "country_id": 91},
        {"address_id": 75, "city_id": 61, "country_id": 75},
        {"address_id": 88, "city_id": 40, "country_id": 60},
        {"address_id": 98, "city_id": 82, "country_id": 75},
    )
    assert tuple_ == select


def test_select_raise_ValueError_with_aggregate_functions_without_flavour_dict(amodel: IStatements[Address]):
    with pytest.raises(FunctionFunctionError) as e:
        amodel.select(lambda x: (Max(x.address_id)))

    mssg: str = "You cannot use aggregation method like 'Max' to return model objects. Try specifying 'flavour' attribute as 'dict'."
    assert str(e.value) == mssg


def test_where(tmodel: IStatements[_TestTable]):
    instance = create_instance_of_TestTable(3)
    tmodel.insert(instance)
    where_clause = tmodel.where(lambda x: x.Col1 == 2).select_one()
    assert 2 == where_clause.Col13


def test_order(tmodel: IStatements[_TestTable]):
    instance = create_instance_of_TestTable(3)
    tmodel.insert(instance)

    query = tmodel.order(lambda x: x.Col10, order_type="DESC").select()
    assert [3, 2, 1] == [x.Col10 for x in query]


# endregion
